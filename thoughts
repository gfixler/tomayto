A word on naming...

automata + maya
automaya (like a contraction of Autodesk Maya)
automayta ("automater?")
tomayta
tomayto
mayta - nah, sounds like "mater"


# how to play with hotkey sets

cmds.hotkeySet(query=True, hotkeySetArray=True)
cmds.hotkeySet(query=True, current=True)

cmds.hotkeySet("MyNewKeySet", current=True) # creates if non-existent

cmds.hotkeySet("Maya_Default", edit=True, current=True)
cmds.hotkeySet("MyNewKeySet", edit=True, current=True)


----------------------------

Sun Jan 26 05:23:30 PST 2020

I've been trying to think through the myriad issues remaining before this is in
any kind of useful state, and I feel I'm starting to make some headway. Here's
a brain-dump:

Just as a note, there are still hotkeys unnacounted for, like Tab.

The basic idea of the state machine is that there will be a dict of states,
with state names as keys, and the details of each state as dict values thereof.
To switch states, an event will somehow emit another state's name, and that
state will be looked up in the states dict, and become the new, current state.

I've decided this needs to work in some kind of continuation passing style.
There should be a default handler, tripped by all keypresses, which looks up
the current state, looks up that state's list of events (key presses), looks
for an event that matches what was pressed, and potentially gets back a chunk
of data (or ??? if not), which it interprets. I.E. there won't be functionality
in the events; they're just data, and the two aren't the same (this isn't
Lisp). This means it's easy to write the events data out to JSON files, if not
the code that data is used to invoke. I've been back and forth between ideas of
all functions (capabilities) being in a big vat, like all the functions in Vim
or Emacs being available from anywhere, or them being methods on the state
classes/instances, available only to them. Maybe there can be common
functionality in libraries, beyond state-level stuff? TBD...

I also pondered pushing and popping of states, and replacing of the current
state, and finally realized there isn't really a replacing, ever, just a
pointing to a new, current state, literally just changing the string name in a
property, which references a key in the states dict. Pushing and popping is the
only oddity, because there needs to be a stack. I don't think there always
needs to be a stack, though, but I'm very unsure as yet. It could be that
everything should be a stack, and I'm also pondering everything being a
tree(!), with timestamps, and something like Vim's earlier/later(!!!). TBD...

It occurred to me that often I needed a function-like relationship between
states, where one would pass in an argument, and the next would do some work,
and return a value. This felt insurmountable, briefly, but then it seemed to
fit neatly in with push/pop, and returning simple data. For example, let's say
I want to find the midpoint of 2 other points. I can hit a key to mean that,
which will push the point selector state onto the stack, that I may choose the
first of the 2 points. Let's say I type "O" to mean the origin. The point
selector state would thus return (0, 0, 0)... somehow.

Well, let's say I press <C-m> to choose a midpoint. That fires off the handler,
which gets passed a (key, alt, ctrl, press) value of ('m', False, True, True).
The handler looks up the current state, getting back a dict. It looks in there
for the event dict, and finds the key ('m', False, True, True), a matching
event. Its value is ("PUSH", "PointSelectorState", None)—the equivalent of
"call pointSelector ()"—which it returns. The handler sees that it should push
a new state, and so it instantiates that state, puts it on the [handler's]
state stack, and sets the instance's "pushedValue" (or whatever) property to
None. In the new state, I press "O" to mean origin. The handler looks up the
tuple ('O', False, False, True) in the PointSelectorState's event dict, and
finds the matching tuple as a key. Its value is ("POP", (0, 0, 0)).

----------------------------

Mon Jan 27 03:28:57 PST 2020

It occurred to me later that there's possibly a lot more involved in push/pop
of states. I didn't finish the previous example of a midpoint, so I didn't get
to the part where I need to handle 2 pushed states; I'd need to push
PointSelectorState once, get a value popped back to me, and then push it again,
and get a second one. Now I'm thinking that I need to either make pushing
always happen with a list of states—which could be mapped over, and the
resulting list of results passed to the specified function in the original push
tuple—or I could have 2 pushes, one for pushing a single state, and one for
pushing a list thereof via map.

While I was feeling that all of this is pretty complicated, I also realized,
from a functional programming standpoint, it's also kind of simple. Ultimately,
I just have to put the things I need into these tuples I'm passing around, and
then use them to accomplish what I need, and refine a bit as I understand the
space better. I need to enter 2 states in sequence, and get the results popped
back from each? Just put them in a list, and map over them. I need the pushing
state to know which function to call with the value(s) it gets back from the
state(s) return value(s)? Stick it in the pushing state's tuple, and have the
handler know to use it in that way. Little by little, I should be able to
flatten this space, and slowly get what I need. It really made me long for
types, though. They can really help design a space like this, and then keep you
honest, and on track, as you code to them.

----------------------------

Tue Feb 18 00:57:03 PST 2020

I had a loud, extended conversation with myself today, during this 3-day
weekend, about how to do the thing that's different about what I want, vs, say,
what Vim and Emacs seem to do. The difficult thing that I want is to use states
like functions. This has been a tricky problem. I can't even remember all of
the thoughts and ideas I've had and thrown out so far. Currently, I'm thinking
that all functionality should take place inside a state. If I'm making
something, moving something, etc., there should be a state whose job that is,
i.e., the start state shouldn't get info from a move state, and then call some
move function specified in some returned tuple of info; you should simply enter
the move state from the start state, for example, and return to the start state
once you've moved what you wanted to move.

I've been toying with the idea of 'callable' states, whose reason for being is
to return a value, but the more I've thought about it, the less it's seemed
necessary. I think now that a state should just be able to tell the handler to
pop back to whatever the last state was, and include some value, and if that
state was waiting for a value, great, if not, no problem. I don't have types in
Python, so it'll have to be down to documentation that if you push the
chooseXYZ state, you should expect a popped XYZ value at some point, though as
I build this out, I'm sure I'll add try/excepts around things, so you won't
need every method to exist in your state instances. To that end, re: getting
info back to the 'caller' state, which isn't really calling anything, beyond
pushing a new state on the stack, I'm thinking a few things...

The states need to communicate with the main class. This is where things get
more tightly coupled than I'd like, but I think when instantiating the main
class, you need to pass in a dict of state names paired with class references.
It will then convert the refs to instances, and the names will then refer to
those. When instantiating each, it will also pass in a reference to its own
instance, and each state class will tuck this away in a property for use in
communication. This allows each state to call, e.g., push and pop methods on
the main class.

When push is called with a valid state, a tuple of the state's name and
instance can be pushed onto the main instance's states stack, and then I think
some kind of onEnter method should be called on the new state, if it exists.
This will allow it to do any setup it needs to do, like resetting values. I
don't like it, but these instances will undoubtedly become full of their own
state of variables; I've thought of several needs to that end already. One
issue here is that if a state gets reused, it may be holding on to values from
the first use :( Yay, mutability. I'm thinking that instead of instantiating
state classes up front, I do so only when they're pushed or switched to (are
they ever switched to, but not pushed?), so every time you enter a state, it's
a unique instance, with a fresh state, unless you're popping back to one from
the state stack. I like that. Anyway...

When pop is called on the main instance, a value may be passed (default:
None?), and this should then be relayed to the state popped back to, through
some callback, like "onPoppedBackTo", or even some name that isn't crap. This
is how states can "return" values to their "callers." Imagine you want to move
the selected object. You press 'm', which in the current state means "move".
The handler gets back some info in a tuple, like (PUSH, "move"), where PUSH is
some instantiated object simply used like a symbol in the main class (just a
thought; it can be a string). It pushes the move state onto the state stack,
and calls move's push method (which, maybe, calls to its fellow onEnter method
before proceeding?), possibly passing in some info, like which state called it
(or not - just a thought). I'm not sure that it's important that states know
they were pushed, although, I do think it's at least somewhat important that,
if you're looking for a return value, you push a state that's going to pop one
back to you (I'll have to ponder ways of making such relations more rigorous
later). So, now you're in the move state, and its onEnter method is called by
the handler. The first thing it does, say, is call:

    self.handlerClass.push("chooseXYZ")

There would be a plethora of ways to choose some XYZ point in the chooseXYZ
state, like asking for the origin, or the worldspace location of some existing
object, or vertex, or some relative offset from one of them, or a user-entered
value, or even a midpoint of two other points, or the average of a bunch of
them. This is where it really gets interesting, because move wants a point, but
I can now tree off through states into a complicated answer, like the midpoint
of the origin, and the midpoint of an existing locator, and some user-entered
point, and only when I've finished specifying all of that, would the move to
that concocted location finally happen. This is all being done essentially
through a message-passing system, so there have to be ways to pass messages,
receive them, and act upon them once received. This is where the popping comes
in...

So I'm in the chooseXYZ state, and I hit 'o', say, which means "origin." The
main instance receives (POP, (0, 0, 0)) from the event dict, or perhaps there's
a handler, so it receives (POP, self.popOrigin), and the main handler calls the
local handler method returned, which returns (0, 0, 0), and then it pops the
state, gets the new current state, and calls its onPoppedBackTo method with the
(0, 0, 0) value, which it knows (based on its own local info, and the fact it's
the move state) to use to move the current selection (probably mapping over it)
to that point (the origin). So complicated!

It's thus really down to each state instance to keep track of what values it's
received, and thus what its own internal state is, so that, in the case of a
midpoint state, it would see that it has no points yet, and make a call to push
the chooseXYZ state. When that state popped back to it with a value, it would
have its onPoppedTo method called with that value, and would determine that
this was its first point, and immediately push chooseXYZ again. When popped
back to again, it would have its second value, and would thus call to pop, and
pass the midpoint of the two values (via message passing through the main
instance's pop method) to whatever state was beneath it on the stack.

It feels tedious and overblown, but I think if I can implement this much of it,
and start to use it, I'll see ways of simplifying, maybe with declarative
generation, e.g. some way of saying you need values from 2 other states,
handled by a local method, like:

    self.handlerClass.stateCall(self.doMidPoint, [chooseXYZ, chooseXYZ])

...which would get a value from chooseXYZ twice, and then pass the results to
the doMidPoint method, which would then call to the handlerClass.pop method
with the computed midpoint. Just another thought.

----------------------------

Wed Apr 22 23:08:57 PDT 2020

I've reached a point where I want to think about the organization of all of
these [very pre-alpha] states I'm starting to build, both as core libraries, and
as something - scripts? plugins? - that a user of the library can add. One thing
that's very different about this, than, say, Vim (the inspiration for this whole
project), is that Vim is a flat, global space of keys per maybe a half-dozen
modes, whereas this project is a huge tree you can walk all around in, with key
mappings changing completely at every state change. The most 'state-machine' you
get in Vim, beyond its base modes, is key sequences, like gUU to upper-case a
line, before you get dumped right back into one of the few main states; it's
always a text-editor, whereas what I'm builing here is whatever you want it to
be in each state.

With this project, I can (eventually, when it all works) be in the start state,
hit a key, and then be in a window-making mode, then hit keys to create layouts
and controls in the window design window, walk around the hierarchy of those,
rearranging things, then choose to label a control, at which point I switch into
a vim-like interface, live-typing the name right on the control, but with a
bunch of Vim's powers (at least, on one line). Then I can kill out, decide to
create a sphere, and then place it by selecting the midpoint of the origin and
the position of an existing object. Then I can jump into myriad file browser
like idea I've had. This graph-walking, pushing and popping states all the
while, changes how hotkeys can be defined.

Currently, I'm thinking that core.py stays, and contains the main class, with
the main handling routine, and related helpers. I'm thinking that every logical
grouping of states, like all the Vimline stuff, or a host of object selection
stuff, gets its own module, and I imagine dozens of these, perhaps, maybe
gathered into a states folder(?), defining the batteries-included, core library
abilities of the project. A point release and docs (if I ever bother) would
serve to define which things a user could count on existing, like selection
states for being able to grab items from the scene in various ways to work on.
This is important, as such things will need to be hooked up to by string, or by
direct reference to callables (which is one reason I'm thinking of python files,
instead of, say, some JSON file, or parseable config file, because then I can
just point to other things in Python space). I've already extracted the Vimline
stuff from exampleUsage.py to vimline.py, though haven't committed anything, as
there's so much to figure out about how it (and every other such module) gets
reintegrated into the state tree.

Much as I've always kind of hated public/private decisions in OOP, and the
accidental complexity it breeds, I think having at least intentionally public
states and events (keymaps), and presumably private ones might make sense here.
Once you're in selection mode, there's a bunch of possible ping-ponging around
in there to add and remove things from selection, before finally popping back
out to whatever wanted you to select things in the first place. Same for the
Vimline idea - presumably something wants you type something out, in the nice,
convenient editor that Vimline [eventually, hopefully] provides, and there's a
ton of bouncing around into and out of command, insert, and visual modes in
there, all of which don't make sense external to working in Vimline. There is a
thought, though, that something like selection mode could use filtering, and for
the years this idea has been kicking around in my head, I've presumed you'd
positively add the states you want, where you want them, e.g. I only want
selection of meshes and locators for this operation, or just visible things,
possibly bundling these choices up, and naming them for reuse. This feels like a
breaking of OOP's Law of Demeter.

I've run into that a lot while thinking about breaking up exampleUsage.py this
past week, and realizing that, at least as I've had it in my head, I keep
needing to reach into states, and keymaps, or deep into a stack of states, to
insert handlers at that level. There's no global, flat terrain in which to
unload all the event handlers you want; you have to wander out to some area of a
tree, and say "at this point I'd also like to be able to do this," and insert
event handlers into the keymap, with connections from there to who knows where
else? I can imagine trying to pull the needs out to the surface, to provide APIs
to accept keymap events and handlers that a particular module can insert in, or
have the core system insert in, but that all feels really messy and complex,
like I haven't really found the truth, the kernel of this idea yet. It feels
like the kind of thing that works great, if you know a lot, and walk a fine line
through the minefield of bad ways of structuring things. This isn't as big a
deal when it's all in one huge file. Everything is a sibling, and of course all
the flat states in one space can call to each other as needed, but when I pull
them all into their own modules, and start to think of a module as having a
purpose, but then realize that somewhere deep into a stack of states in one
module, I may need to evoke selection, because at that point, I need to be able
to select things, then it starts to get weird. Suddenly, every module needs to
import every other module, and you run into a gross, circular imports.

----------------------------

Fri Apr 24 01:11:21 PDT 2020

Okay, I think a lot of the confusion has suddenly evaporated. The solution is
actually a lot like how Vim (and other things) work. I just wasn't seeing it,
because I'm not used to needing to do this in a graph/state machine.

I'd like to keep a DAG of states/modules, and I think sensible reworkings/
layers of indirection should guard me from circular dependencies/imports.
Basically, I'd like a start.py that imports all the other state modules, with a
start state (class) that simply does what it's already doing, but with state
classes from the modules. Any states that require states in other modules will
simply be in modules that import the needed ones, and do as above, working with
states in those modules. It's fair game once you've imported a module to use the
states in it, just as you use the functions and such in modules you import. No
breaking of the Law of Demeter there. For plugins, they can do the same, because
they're based on a point release (eventually, and just on my knowledge of things
for now), and so it's fair game for them to expect anything and everything in
the project to exist. It feels backward to me, because the plugins depend on the
project, and so the project feels like it should be a submodule of each plugin,
but I don't think that holds up, nor makes any sense.

Just as with Vim, and other things, there should be an expected place for
plugins, and you put them in there. This is a little trickier as a Python-only
thing, without, say, dotfiles, which would go in your home space. It doesn't
feel right to stick these in the project, because a proper project installs
itself to some folder you don't typically visit, and your things should really
be in your homespace, but you don't typically install Python scripts there. It
would have to dynamically load them through the importlib module, which works
(Maya loads a userSetup.py from your homespace), but feels bizarre.

----------------------------

Sat Nov 28 21:02:54 PST 2020

Time for some more thoughts, after 6 months away. I'm now a Twitch streamer, as
of about a week ago. My old pal, Ben, popped in days ago, and thought what I was
building here looked ripe for stack based programming. We followed up that
mention in the Twitch chat with a few hour Zoom session, going over various pros
and cons. I still don't think I love it for how the entire system works, but now
I'm pretty sure I want stacks I can spool up in the moment, to use them where
they make sense to me. I'm open to the idea that a stack *is* the way to go; I
just don't see it yet. I need more time, and to play with the idea first, a lot.

I've thought more about the selection engine I want... Right now, I can choose
transforms of a few types (mesh, locator, and camera), which labels them with
letters, which then become keypress selection toggles. The obvious issues with
this are things out of view, and labeling sets of transforms that outnumber the
keys you use to toggle-select them, currently A-Z, a-z, and 0-9.

I want a pop-up, filterable UI of nodes. Typing out a regular expression name
(Vimline) filters down the list. The names visible in the scrollList each have
letters; when pressed, they toggle selection, both in the list, and in Maya. I
also want to filter in this way by node type, and maybe some other things - how
to choose between these is TBD. Regardless, selected items can easily be added
to new, or existing, named sets, and it should be fast to select, add to a set,
clear selection, and do it again.

In addition to creating selection sets, I want to see them in a pop-up list, and
easily select, and do boolean operations on their members (more on that next),
but I also want sets of sets, e.g. a set of sets of vertices from a character's
face, another around the verts of a different character's face, another around
different types of objects in the scene, etc.

Quick example of the UI around set selections, and their boolean operations...

Say we have the following, named, selection sets of vertices of a face:

a face
b left eyelid
c right eyelid
d lips
e left ear
f right ear
g nose

As I press the letters on the left, the selection (UI and Maya) changes to that
set. If I hold shift when selecting, it adds the selection (both, again) to the
existing one. So, I can hit e to replace the selection with the vertices of the
left ear, then F to add those of the right ear. If I want to add an "ears" set,
as the combination of the two ear vert sets, I can then hit whatever means
create new set from selected, typing in "ears" (Vimline), adding an h entry.

If shift+letter adds to the set, I'm thinking ctrl+letter removes from it, so I
could press a to select the whole face of verts, then ctrl+b, to remove the left
eyelid, then ctrl+c to remove the right eyelid, from the active selection. If I
went through all the ctrl+ letters, from b to g, I'd remove everything from the
face that isn't those things, and end up with, say, only the forehead, cheeks,
and chin verts selected. I've written little scripts to do boolean operations on
verts like this in the past, which was very helpful for weighting characters.

----------------------------

Fri Jan  1 07:21:07 PST 2021

SelectionList thoughts today. I wanted a way to pop up a list of text values,
quickly select from them by a letter to the left of each, in the first column,
which toggles selection. I have that working now, and I have a [non-committed]
demo state w/ keymap that lets me pop open a window, listing all items in the
current Maya scene, with prefix letters that don't move. C-u and C-d move the
list up and down by page (want to make that half-page later, and use C-b and
C-f for page, as in Vim). Pressing the letter prefixes toggles selection of the
items, which persists through refreshes, scrolling, etc. Hitting enter closes
out the window, and pops back from the SelectionList state.

I keep thinking of ideas, now that I can see it working, so I wanted to jot them
down, as I'm going to forget them.

- filtering of entries, for now only through regex of the text (/ to invoke)
    - this can use Vimline, and put it through its paces
- clearing selection
- selecting all, both globally, and just what's visible
- what's visible can change not just through scrolling, but also filtering
- various sorting modes
- need to make the demo state work more generically, and take inputs
- filter to only selected items, or only unselected
- enter should pop the selected items back as a list (this is a state thing)
- callback, so, e.g. changes can happen in Maya on selection toggles
    - probably easier to deal with from state methods
- eventually allow non-text items, and even wholly mismatched things
    - variable height, complex UI entries, e.g. multi-line addresses
    - not sure how searching and highlighting would work...
- highlighting letters in words, instead of prefixing - easier to see quickly
- automatic window resizing to fit contents well
    - already doing this in the demo
    - limit size so it doesn't get huge
    - max values settable in settings(?)
- keep the order of selections?
    - could replace selected bool with increasing numbers
        - no need to reuse - just sort by numbers and return, sans-numbers
    - maybe return different things via different hotkeys?
        - C-o = ordered selection
        - C-u = unordered selection (alias for Enter?)
        - C-A-o = ordered non-selected
        - C-A-u = unordered non-selected

TODO items:
- ensure scrolling up and down is the same amount (currently off by 1)
- don't allow keypresses off the bottom of the list to toggle selections

----------------------------

2021-11-24 01:34:06 PM

I've been thinking about key sequences and chords this past week. I've also
been thinking about how key events should work. I haven't been happy with how
the library works so far, as it can be very tedious to build out states. I've
wanted something compositional. My thoughts are very jumbled right now, so I'm
using this file to start refining them (that's what this file is for, really).

Currently, the keymap in each state is a dict, with "events" as keys, and a
tuple of an action string (either "PUSH", "POP", or "RUN"), followed by some
necessary bits, specific to the action type. One problem is that if I want to
create a key sequence, I have to break it up over states, so I add the first
key in an event to a particular state, and push another, new state, in which I
put the next key, and repeat until I've finished the sequence. It's a lot of
boilerplate, and a lot of places to keep track of, and for bugs to hide in.

I'd like to simplify with composable events. Some thoughts:

e = Events()        # actual name/how it works TBD
e.c_x | e.c_f       # ctrl+x, then ctrl+f
e.n & e.m & e.r     # n, m, and r keys, chorded (pressed together)
e.ca_h              # ctrl+alt+h
e.ac_h              # synonym for e.ca_h
e.b_h               # possible expression of alt+ctrl (b for both)
                    #   i.e. a = alt, c = ctrl, b = both?

I wouldn't need to create all of the properties on the Events instance; this
would be done by parsing the string sent to the instance's __getattr__ method.

Maybe sequential keys could become a list of events:

[("x", False, True, True), ("f", False, True, True)]

Maybe chorded keys could become a list inside an event:

(["n", "m", "r"], False, False, True)

Alternatively, maybe I use classes:

Seq(e.c_x, e.c_f)
Crd(e.n, e.m, e.r)

I don't love that, because I want an algebra of events, e.g., create some seqs
or crds somewhere:

complf = e.c_x | e.c_f      # file completion prefix sequence
prag = e.l & e.a & e.n      # chord for haskell language pragmas

Then use them in other seqs and crds:

complf | e.p & e.y & e.t    # filter to just python files
complf | e.h & e.a & e.s    # filter to just haskell files

prag | e.g & e.n & e.d      # generalizedNewtypeDeriving
prag | e.n & e.m & e.r      # noMonomorphismRestriction

These | and & operators would be creating events, composing events
into new events, immutably.

As an aside, I need a way to express keys that can't exist in a property name,
like % and F1, as e.c_^ (go to alternate file in Vim) isn't valid. I think it
might be nice to allow dict lookup of strings, e.g. e["c_^"], but I also think
I need to standardize around the best name for these things, i.e. the ^ is most
standardly known as the caret, though people call it the exponent symbol, or
even "hat". So, e.c_caret should work, as should e.f1. I'd also like to be able
to ask the name of things, e.g. with e.getSymbolName("^") and have it retun
"caret". There will be weird keys, like Tab and Backspace, which aren't
assignable as hotkeys in Maya, but which I can get to by hacking into some
existing callbacks. That's TBD.

Composition of events means I also need to deal with prefix collisions, i.e. if
you can press the keys ab in sequence to do something, and you can also press
abc to do something else, then pressing ab means you're in a weird state, where
the system doesn't know if you mean ab, or if you're about to type c. Vim gets
around this by waiting 1 second to see if you continue on, and if not, it emits
the event for the now fully-entered, smaller subsequence. I handle such
sequences entirely manually at the moment, by linking a single keypress to
another state. Composition means I can automate sequences, but I need a way to
detect when sequences overlap, and a plan for handling such overlaps.

Waiting a second when event subsequences overlap is tricky. I'll be in Maya, so
I'll likely be using the evalDeferred tricks I've come up with elsewhere. I
would like to allow that dependency to be injected, or set to something else,
in case this library grows beyond Maya at some point.

----------------------------

2021-11-28 Sunday

I thought of a counterpoint to how I was imagining a chorded key event algebra.

    e.c_x & e.u & e.P

That represents a chord of ctrl+x, u, and P, but a chord is supposed to be
struck at [roughly] the same instant. This imagines that I can hit ctrl only
for the duration of the x, and shift only for the duration of the P, when
really I'd have to be holding shift and ctrl the entire time to have those keys
register, but then the events that don't have those modifiers wouldn't fire.

Several workarounds:

1) don't allow modifiers in chords

    I don't like this. I want modified chords

2) promote everything, so all events share any given modifiers

    Not a fan; I don't want to correct wrong data

3) error out at runtime

    Nah... I'd rather make illegal states unrepresentable

4) move sequences into the parsed property descriptions

    I'm leaning toward this.

    So instead of:

        e.c_u & e.c_p   # ctrl+u and ctrl+p together

    I'd do this:

        e.c_u_p

    The problem with e.c_u_p is that it could parse as a ctrl-modified u and p
    chord, or as a no-modifiers c, u, and p chord.

    A possible workaround, though I'm not 100% sure how I'd implement:

        e.c.u_p

    Special keys would work this way:

        e.c.caret_amp   # ctrl+^ and ctrl+& together

    This brings up the problem of shift being baked into the ^ and & chars.
    I.e. it wouldn't really be possible to do e.g_H, because you'd need to hold
    shift for the H, and not hold it for the g. At some point, I think the
    system just has to do its best, and the user has to not build broken
    things, but it would be nice to figure this out cleanly.

    I've been predicting I'll need some up-front parsing of _, because just
    splitting on _ for e._ would yield ['', ''], and e.c__ is also weird.

    So the above means we no longer need & for chorded key events, which means
    we're less tied to | for sequential events, so we could use something else
    for sequencing them, like:

        e.h_p > e.n_m_r     # h and p chord, followed by n, m, and r chord

    Though I quite like sequencing looking like using pipes in Linux:

        e.h_p | e.n_m_r

    Currently I need to figure out:

        1. a key event format
            - and write a parser (with tests)
        2. a key event set format, which makes it easy to:
            - explore the state space
            - figure out where we are in a chord/sequence
            - add and remove keys/chords/sequences live
            - combine key event sets via simple composition
        3. timeouts for chords and sequences
            - via cmds.evalDeferred

----------------------------

Tue Apr 26 16:10:13 PDT 2022

Had a big upheaval last night, care of a discussion in the Plover (open source
steno) Discord. I was not in the discussion, but it was about Forth. User
"Charley stenomod.blogspot.com" is an old Forth guy, and was speaking of it
lovingly. I recalled this project, and my friend, Ben Deane's strong push to
have me switch from a state machine approach to a stack based one. I couldn't
see it at all, but eventually came around to thinking it could be useful for
some things, but certainly not the whole system.

Meanwhile, that project stalled, because I couldn't find what I really wanted in
terms of a core model. Everything was too thick. Anything I wanted to do
required me to write yet another state, or 5, and it all got too cumbersome to
be bothered with. My main problems with stacks are 1) they seem like they would
get super messy as I use them, with everything I do putting a result on the
stack, often in the way of things I was in the middle of, and 2) something I
really clarified in my head last night, that all the operations would have to be
out in the start state now, competing for simple keys, like s, because it's no
longer about walking into states, each with their own key map, carrying ideas
along with me, but rather, pushing things onto a stack, then doing things
on/to/with the stack, always from the initial state.

So on one hand, states are too deep and too separated, and on the other hand,
stacks are too flat and too combined. Last night, it finally clicked for me how
to combine the two, something I've thought might be possible since last year,
but remained opaque to me ever since. It's quite simple; I just couldn't see it.

Just as a point of reference, for comparison sake, let's say I want to move a
sphere to the midpoint of 2 other midpoints, and the first midpoint is between a
cube's 3rd vertex and a locator, and the other is between the origin and a point
I specify by typing in an XYZ coordinate. This will be sloppy, but here's a take
on what that might look like in my state based model (states in caps for
clarity):

Move works on selection, so we first need to select the sphere. I'm in the START
state, and hit s for select, pushing SELECT onto the state stack (there is a
stack in my states, but it's for the states themselves). I want the sphere, so I
hit m, pushing MESH SELECT. The meshes are tagged with letters, and I press the
letter of the sphere to toggle its selection, then press return to confirm,
popping back to MESH SELECT, which in turn "onPop" pops back to SELECT, which
"onPop" pops back to START. Time to move it to the midpoint of midpoints...

I press m, pushing MOVE, which pushes POINT SELECT, then M, pushing MIDPOINT,
which pushes POINT SELECT for the first point. I press M again, pushing another
MIDPOINT, which pushes another POINT SELECT. I press v, pushing VERTEX SELECT,
which pushes SINGLE MESH SELECT, and in there I do something to select the cube,
and it pops back to VERTEX SELECT with that, and pushes VERTEX SELECT FOR GIVEN
MESH with that target mesh. I use a number of tricks in there to pick the 3rd
vertex. It pops back with that vertex to POINT SELECT, which pops back to
MIDPOINT, which pushes POINT SELECT again for the second point. I press l,
pushing LOCATOR SELECT, pick the locator, and it pops back 2x to MIDPOINT, which
evals, popping back its midpoint to the outer MIDPOINT, which now wants its
second point, and pushes POINT SELECT again. This is to be another midpoint, so
I press M, pushing MIDPOINT, which pushes POINT SELECT. I press O, which pops
back 2x with the origin to MIDPOINT, which pushes POINT SELECT for its second
point. I push something to pop up a state-machine XYZ input box, type in the XYZ
component values, confirm, and it pops back to MIDPOINT with that point. The
midpoint evals, popping back to the outer MIDPOINT, which evals, popping back
with the final midpoint of midpoints to MOVE, which finally moves the selected
sphere to that point. *takes a breath* Along the way, any states that messed
with the selection politely restored it as they were popped away from, so all
the vert, mesh, locator selection in the middle didn't affect things.

This is massively complex. I had to go back and edit things that I'd forgotten
to type up several times (and struggled to explain it out loud to myself last
night, and again today). I also realize that by point 3 (point 1 of the second
inner midpoint), if I wanted to change point 1 of the first midpoint, it's a
struggle. At best I could kill out of the second point by selecting none,
leaving me in the outer midpoint, at which point I could hit something in that
state to mean redo the first point, but the midpoint info from there is gone, so
I'd have to redo it entirely. It has all the problems of hierarchies. It's
cumbersome and complex, and hard to reason about.

The problems with stacks I think I've overcome, with a night of thought. First,
the problem with the stack becoming a mess; Charley from the Discord says Forth
programmers obsess over a clean stack, which is good to know. I think the simple
answer there is that nothing goes on the stack unless I put it there, and I only
put things there because I'm doing something with them now. If I make a sphere,
it doesn't go on the stack. Instead, I make a sphere, and it gets pushed to a
last-made-object list, and maybe also a last obvious thing list, and I can push
either onto the stack from there. There can be little lists for everything -
last moved things, last made thing, last selected thing, last point moved to,
last opened file etc. There can be a mode just for pushing things on the stack,
full of keys I can use to push anything I've dealt with to the stack.

Also, I want a clear stack button. I use space in Vim to clear selection and
command line. That might work. Space to dump the stack, and start fresh. I also
want to be able to undo, and put things back on the stack, so there will be
another stack of things that have been popped off, coupled with actions taken in
Maya to undo (this part seems tricky).

So how might it look to do what I did above - midpoint stuff - with a stack AND
states? Let's see:

I press s to enter SELECT state - I still have my states. In there I press v for
VERTEX SELECT, which pushes MESH SELECT mode, pick a mesh, then enter VERTEX
SELECT FOR GIVEN MESH mode where I can use a number of options to get at a
vertex. When I'm done, it pushes the vertex to the stack, and pops me back out
to the START state. I'm free. I can decide at that point I'm done, and do
nothing, and maybe clear the stack, or do things with that vertex, like scale
it. I decide to push the next point, so I press s to enter SELECT state again,
press l for LOCATOR, pick one, pushing it to the stack, and pop back to START. I
press a midpoint thing, which pops the 2 points, and pushes the midpoint back
on. I do this again for the origin and typed-in points. So now I midpoint the
top 2 things on the stack again, and I have 2 midpoints on top now, so I do it
again. Now I want to move a sphere - I can still use a select mode to pick a
sphere, but then I can push it to the stack, and then push a thing to apply move
to the top 2 things on the stack. Done. I didn't get trapped in a corridor of
needs that the MOVE state was waiting for.

I can have an arsenal of things ready to work on selection, using the stack. I
get a point onto the stack, then select some things, then call the move selected
functionality, which pops the point from the stack, and moves the selected
things. It's so simple. It gives me so many options, too. I could push a point
and then a transform, and then call move on the top 2 items, somehow, or push a
point, select some things, then call move on selection using the point on the
stack. The same move command could also move objects to objects, so I push
sphere, then cube, then say move, using the top 2 items, and it moves the cube
to the position of the sphere (ultimate to penultimate; last object is active
object), popping both. I realize I mean the other way, so I undo, which moves
the cube back, and puts the names back on the stack. I hit the swap button to
swap the top 2 items, and redo the move, and the sphere moves to the cube now.
The move function could also be smart, seeing that one of the top 2 items is a
transform, and the other is an XYZ, and regardless of order, it just works, and
that can become idiomatic in my mind, and quick to rely on.

For things where order matters, and because it's likely I'll do a ton of things
to the top 2 items, I could even make a whoops button that undoes, swaps the top
2 items, and replays the last command, and that would work as a toggle! This is
blowing my mind. This model really gives me that "late binding" I always
(misuse) want. Say I have a "put object on top of other object" command. I push
2 objects, intending to do that, then realize I really meant "put object beside
other object," so I just hit that command instead. I really thought I wanted
Vim's verb-then-object thing, but this is feeling so much more powerful and
composable. It feels like states are inheritance/hierarchy, and stacks are
composition. I know what I like. The blend of the two is wonderful. I have so
much to explore now. I feel unblocked.

One problem I had before, thinking I wouldn't have my states anymore, was how to
push the origin onto the stack. Does that ability just sit out in the START
state? No, it's still in the SELECT POINT state, but that state isn't something
called from MOVE, or whatever needs it, it's just about picking a point to push
onto the stack, and then you're done. Do whatever you want with it after that.

So now I can imagine a number of stack commands, but have to decide if I just
want them out in the world, or under some stack prefix. It feels like they're
much more useful than the plethora of Maya things, since I'll be using them with
all the Maya things, so they should dominate the START state.

I also realized there will be times when things are buried a bit on the stack,
and I thought of having another stack I could pop them over two. Say I push 4
points and need to midpoint each pair, then midpoint the results. I could
midpoint the top 2, then move the resulting point over, then midpoint again, and
move the result back. Or I could move 2 over (taking a count even, like Vim),
midpoint, move them back, midpoint, then midpoint. I think rotating the top n
items is a normal stack thing, but it feels a little harder to keep right in my
head. Maybe I'll just play until it's idiomatic.

